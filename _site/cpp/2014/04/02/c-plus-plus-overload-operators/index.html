
<!DOCTYPE html>
<html lang="en">
  <head>
  	<meta name="baidu-site-verification" content="pfxBYSccpl" />
    <meta charset="utf-8">
    <title>YeGe'Blog-C++中的操作符重载</title>
    <meta name="description" content="">
    <meta name="author" content="YeGe Blog">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/twitter/bootstrap/css/bootstrap.2.2.2.min.css" rel="stylesheet">
    <link href="/assets/themes/twitter/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

  </head>

  <body>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container-narrow">
          <a class="brand" href="/">BloGe</a>
          <ul class="nav">
            
            
            


  
    
      
      	
      	<li><a href="/about.html">关于</a></li>
      	
      
    
  
    
      
      	
      	<li><a href="/archive.html">归档</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">分类</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/pages.html">导航</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">标签</a></li>
      	
      
    
  



          </ul>
        </div>
      </div>
    </div>

    <div class="container-narrow">

      <div class="content">
        
<div class="page-header">
  <h4>C++中的操作符重载 </h4>
</div>

<div class="row-fluid post-full">
  <div class="span12">
    <div class="date">
      <span>2014-04-02</span>
    </div>
    <div class="content">
      <h5 id="">算术运算符的重载</h5>

<p>算术运算符的重载要注意返回值的类型，<code>+ - * /</code>计算结果要以 pass-value 方式传递一个变量做返回值，这样可以对多个变量的连续运算进行支持。</p>

<p>对于数乘形式的运算 <code>A*k</code> 可以作为类的成员函数进行重载，而 <code>k*A</code> 无法作为类的成员函数，可以以友元函数的形式进行重载。以满足对 <code>A*k</code> 和 <code>k*A</code> 的支持。</p>

<p>对于前置 <code>++(--)</code> 也要以 pass-value 方式返回一个 const value，这样禁止 i++++ 通过编译。 对于后置 <code>++(--)</code> 要返回一个 reference-to-non-const ，对 ++++i 提供了支持。 后置 <code>++(--)</code> 的效率要比前置 <code>++(--)</code> 效率高。后置 <code>++(--)</code> 需要用一个 int 做参数来区别前置 <code>++(--)</code>。</p>

<pre><code>class vector{
  private:
    float x;
    float y;
  public:
    vector(float x,float y):x(x),y(y){};
    vector operator+(const vector &amp; v) const{//+
        return vector(this-&gt;x+v.x,this-&gt;y+v.y);
    }
    vector operator*(float k) const{ //数乘，V*k
		return vector(this-&gt;x*k,this-&gt;y*k);
    }
    vector &amp;operator++(){//前置++ 
        ++x;
        ++y;
        return *this;
	}
    const vector operator++(int){//后置++ 
        vector tmp=(*this);
        ++*this;
        return tmp; 
	}
    friend vector operator *(float k,const vector &amp;v);//数乘，k*V
}

vector operator*(float k,const vector &amp;v){
    return v*k;
}</code></pre>

<p><br /></p>

<h5 id="___">输入输出操作符 <code>operator&gt;&gt;</code> 和 <code>operator&lt;&lt;</code></h5>

<p>为了支持输入输出运算符，也需要这两个操作符进行重载。</p>

<pre><code>class vector{
  private:
    float x;
    float y;
  public:
    vector(float x,float y):x(x),y(y){};
    std::ostream &amp; operator&lt;&lt;(std::ostream &amp;os){
        os&lt;&lt;&quot;(&quot;&lt;&lt;v.x&lt;&lt;&quot;,&quot;&lt;&lt;v.y&lt;&lt;&quot;)&quot;;
	}
}

vector v(1,2);
v&lt;&lt;(v&lt;&lt;cout); //相当于 cout 在 operator&lt;&lt; 中做参数 </code></pre>

<p>为了符合 <code>cout&lt;&lt;v</code> 的形式，可以以友元函数的方式对 <code>operator&lt;&lt; (operator&gt;&gt;)</code> 重载。</p>

<pre><code>class vector{
  private:
    float x;
    float y;
  public:
    vector(float x,float y):x(x),y(y){};
    friend std::ostream &amp; operator &lt;&lt;(std::ostream &amp; os,const vector &amp;v)
}

std::ostream &amp; operator &lt;&lt;(std::ostream &amp; os,const vector &amp;v){
    os&lt;&lt;v.get_x()&lt;&lt;&quot;,&quot;&lt;&lt;v.get_y()&lt;&lt;endl;
    return os;
}
vector v(1,2);
cout&lt;&lt;v; //vector 相当于 operator&lt;&lt; 的参数</code></pre>

<p>reference-to-const做参数对常量支持的同时，也支持了非左值的类型 <code>cout&lt;&lt;v+v</code>。 为了支持 <code>cout&lt;&lt;v&lt;&lt;v</code> ，需要返回 ostream 的引用，除了效率的原因，还因为 ostream 不提供复制构造函数。</p>

<p><br /></p>

<h5 id="__">数组索引操作符 <code>operator[]</code> 重载</h5>

<p><code>operator[]</code> 提供以下两种重载形式：</p>

<pre><code>reference operator[] (size_type n);
const_reference operator[] (size_type n) const;</code></pre>

<p>第一种形式可以通过索引对数组元素进行修改，第二种是通过返回的常量引用可以获取数组的内部元素。</p>

<pre><code>template &lt;typename T,int row,int col&gt;
class Array2d {
  class Array1d{ //nested class
    public:
        const T &amp;operator[](int i) const{	//overload operator[]
            return    array[i];   
        }
        T &amp;operator[](int i){	//overload operator[]
            return    array[i];   
        }
    private:
        T array[col];             
  };
  public:
    const Array1d &amp;operator[](int i) const{	//overload operator[]
        return    array[i];   
    }
    Array1d &amp;operator[](int i){	//overload operator[]
        return    array[i];   
    }
  private:
    Array1d    array[row];     
};

Array2d &lt;int , 3, 7&gt; array;
array[2][2]=2;
std::cout&lt;&lt;array[2][2]&lt;&lt;std::endl; //print 2</code></pre>

<p>在上面的代码中，以 nested class 的方法，并且对 <code>operator[]</code> 进行重载，实现对二维数组中的元素可以用<code>array[][]</code> 方式进行访问。</p>

<p><br /></p>

<h5 id="dereferencing_operators">智能指针中Dereferencing Operators</h5>

<p>在智能指针的设计中需要对其内部的 raw pointer 进行解引，智能指针的使用更像指针，主要涉及到 <code>operator*</code> 和 <code>operator-&gt;</code> 两个操作符。 这两个操作符重载的形式如下:</p>

<pre><code>T&amp; operator*() const;
T* operator-&gt;() const;</code></pre>

<p>在第一个重载中，返回 reference 的主要原因是为了保证多态性。，以 pass-value 返回可能会引起切割。 而且这两个重载在类内被 const 限制，主要是防止 raw pointer 被修改。</p>

<pre><code>template&lt;typename T&gt;
class PTR{
  public:
    PTR(T *p):ptr(p){}
    T &amp;operator*() const{
        return *ptr;
    }
    T *operator-&gt;()const{
        return ptr;
    }
  private:
    T *ptr;      //raw pointer
};

PTR&lt;std::string&gt; str(new string(&quot;i'm here&quot;));
std::cout&lt;&lt;&quot;length &quot;&lt;&lt;(*str).size()&lt;&lt;std::endl;	//print length 8
std::cout&lt;&lt;&quot;length &quot;&lt;&lt;str-&gt;size()&lt;&lt;std::endl;	//print length 8</code></pre>
    </div>

  
    <ul class="tag_box inline">
      <li><i class="icon-folder-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#cpp-ref">
    		cpp <span>11</span>
    	</a></li>
    
  


    </ul>
    

  
    <ul class="tag_box inline">
      <li><i class="icon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#operators-ref">operators <span>3</span></a></li>
    
  



    </ul>
    

    <hr>
    <div class="pagination">
      <ul>
         <ul>
     
        <li class="next"><a href="/cpp/2014/04/03/c-plus-plus-new-and-delete" title="C++中的 new 和 delete 操作符">&larr;上一篇 </a></li>
      
	  <li><a href="/archive.html">更多</a></li>
	  
        <li class="prev"><a href="/cpp/2014/03/28/c-plus-plus-variable-store" title="C++中的变量存储"> 下一篇&rarr;</a></li>
      
      </ul>
      </ul>
    </div>
    <hr>
    
  </div>
</div>


      </div>
      <hr>
      <footer>
        <p>&copy; 2014 YeGe Blog
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
        </p>
      </footer>

    </div>

    
  </body>
</html>

